/*
 *   Document    : primitives.styl
 *   Author      : DPR
 *   Description : Primitive mixins.
 */


/*
 * Generates a plane
 *
 * @param width
 * @param height
 * @param translate-x
 * @param translate-y
 * @param translate-z
 * @param rotate-x
 * @param rotate-y
 * @param rotate-z
 * @param color
 * @param mesh-id
 * @api   public
 */

plane(width = 50px, height = 50px, translate-x = 0, translate-y = 0, translate-z = 0, rotate-x = 90deg, rotate-y = 0deg, rotate-z = 0deg, color = material-color, mesh-id = 0)
    &[data-mesh-id={'"%s"' % mesh-id}]
        set-transform(translate-x, translate-y, translate-z, rotate-x, rotate-y, rotate-z)
        div.face
            quad(width, height, color: color)
            center(width, height)


/*
 * Generates a cube
 *
 * @param width
 * @param height
 * @param depth
 * @param translate-x
 * @param translate-y
 * @param translate-z
 * @param rotate-x
 * @param rotate-y
 * @param rotate-z
 * @param color
 * @param mesh-id
 * @api   public
 */

cube(width = 50px, height = width, depth = width, translate-x = 0, translate-y = 0, translate-z = 0, rotate-x = 0deg, rotate-y = 0deg, rotate-z = 0deg, color = material-color, mesh-id = 0)
    &[data-mesh-id={'"%s"' % mesh-id}]
        
        half_width  = width / 2
        half_height = height / 2
        half_depth  = depth / 2
        
        set-transform(translate-x, translate-y, translate-z, rotate-x, rotate-y, rotate-z)
        
        div.face
            
            // Top
            &[data-face-id="0"]
                quad(width, depth, translate-x, translate-y, translate-z, rotate-x, rotate-y, rotate-z, color)
                transform(rotateX(90deg) translateZ(half_height))
                center(depth, width) 
            
            // Back
            &[data-face-id="1"]
                quad(width, height, translate-x, translate-y, translate-z, rotate-x, rotate-y, rotate-z, color)
                transform(translateZ(-(half_depth)))
                center(height, width) 
            
            // Bottom
            &[data-face-id="2"]
                quad(width, depth, translate-x, translate-y, translate-z, rotate-x, rotate-y, rotate-z, color)
                transform(rotateX(-90deg) translateZ(half_height))
                center(depth, width) 

            // Front
            &[data-face-id="3"]
                quad(width, height, translate-x, translate-y, translate-z, rotate-x, rotate-y, rotate-z, color)
                transform(translateZ(half_depth))
                center(height, width) 
            
            // Left
            &[data-face-id="4"]
                quad(depth, height, translate-x, translate-y, translate-z, rotate-x, rotate-y, rotate-z, color)
                transform(rotateY(90deg) translateZ(-(half_width)))
                center(height, depth)

            // // Right
            &[data-face-id="5"]
                quad(depth, height, translate-x, translate-y, translate-z, rotate-x, rotate-y, rotate-z, color)
                transform(rotateY(90deg) translateZ(half_width))
                center(height, depth)


/*
 * [WIP] Generates a sphere
 *
 * @param radius
 * @param arc
 * @param subdivisions-axis
 * @param subdivisions-height
 * @param translate-x
 * @param translate-y
 * @param translate-z
 * @param rotate-x
 * @param rotate-y
 * @param rotate-z
 * @param color
 * @param mesh-id
 * @api   public
 */

sphere(radius = 100px, arc = 360, subdivisions-axis = 4, subdivisions-height = 4, translate-x = 0, translate-y = 0, translate-z = 0, rotate-x = 0deg, rotate-y = 0deg, rotate-z = 0deg, color = material-color, mesh-id = 0)
    p('radius: ' + radius)
    p('arc: ' + arc)

    arc_radians = radians(arc)

    for i in 0 ... subdivisions-axis

        // Create anchor points

        div.point[data-point-id={ '"%s"' % i }]

            rotate_y = degrees(i * (arc_radians / subdivisions-axis))
            rotate_y = unit(rotate_y, deg)

            transform(rotateY(rotate_y))

            // Create vertical faces for each subdivision along the y axis

            for j in 0 ... subdivisions-height

                // Calculate vertices to determine face size

                // First and last are triangles

                if j is 0 or j == (subdivisions-height - 1)

                    p('triangle:' + j)

                    vertices = _sphere_face_vertices(i, j, 'triangle')

                else

                    p('quad:' + j)

                    vertices = _sphere_face_vertices(i, j, 'quad')


/*
 * Calculate an individual face's vertices from it's current subdivision level
 *
 * @param  subdivision-axis
 * @param  subdivision-height
 * @param  type
 * @return vertices  
 * @api    private
 */

_sphere_face_vertices(subdivision-axis, subdivisions-height, type)
    
    vertices = (0 0 0 0)

    if type is 'triangle'

        // Generate triangle vertices

    else

        // Generate quad vertices 


    vertices   





/*
 * Generates a pyramid
 *
 * @param radius
 * @param translate-x
 * @param translate-y
 * @param translate-z
 * @param rotate-x
 * @param rotate-y
 * @param rotate-z
 * @param color
 * @param mesh-id
 * @api   public
 */
 
pyramid(radius = 200px, translate-x = 0, translate-y = 0, translate-z = 0, rotate-x = 0deg, rotate-y = 0deg, rotate-z = 0deg, color = material-color, mesh-id = 0) 
    &[data-mesh-id={'"%s"' % mesh-id}]

        radius           = unit(radius, '')
        edge_length      = unit(floor(sqrt((radius * radius) / 2)), px)
        half_edge_length = edge_length / 2
        triangle_height  = triangle-height(edge_length, 60)
        face_rotation    = unit(90 - (degrees(acos(sqrt(3) / 3))), deg)
        center_y         = triangle_height / 2

        set-transform(translate-x, translate-y, translate-z, rotate-x, rotate-y, rotate-z)
        
        div.face
            &[data-face-id="1"],
            &[data-face-id="2"],
            &[data-face-id="3"],
            &[data-face-id="4"]
                triangle(edge_length, 60, color: color)
                transform-origin(50% 100%)
                center(0, edge_length)
            
            // Bottom
            &[data-face-id="0"]
                quad(edge_length, edge_length, color: color)
                transform(translateY(center_y) rotateX(90deg))
                center(edge_length, edge_length)
            
            // Back
            &[data-face-id="1"]
                transform(translate3d(0, -(center_y), half_edge_length) rotateX(face_rotation))
            
            // Front
            &[data-face-id="2"]
                transform(translate3d(half_edge_length, -(center_y), 0) rotateY(90deg) rotateX(face_rotation))
            
            // Left
            &[data-face-id="3"]
                transform(translate3d(-(half_edge_length), -(center_y), 0) rotateY(90deg) rotateX(-(face_rotation)))
            
            // Right
            &[data-face-id="4"]
                transform(translate3d(0, -(center_y), -(half_edge_length)) rotateX(-(face_rotation)))
            
